# BlueMonitor — FastAPI Setup Guide
# Version: 2.2
# Last-Updated: 2026-02-15
# Changelog: Enhanced external API auto-discovery with ext: naming convention

Add uptime monitoring, heartbeat push, and a status badge to your FastAPI app.

Documentation: https://www.bluemonitor.org/docs/fastapi

## Update Notice (v2.2)

If this project already has BlueMonitor set up, check for these issues before adding anything new:

1. **External API reachability check**: If the heartbeat has `check_external_api` that checks `res.is_success` to determine status, fix it. Many APIs return non-2xx on their base URL (e.g. OpenAI → 421, Firestore → 404) but are fully operational. Change the logic to: any HTTP response = "ok" (reachable), only connection errors/timeouts = "error" (down).
2. **External API auto-discovery**: If the heartbeat only checks SDK imports (stripe, boto3), also scan for `httpx`/`requests` calls to external URLs and add `ext:` checks for those too.
3. **Bot patterns**: Compare the project's bot patterns against the list in Section 4 below. If missing newer bots (ChatGPT-User, anthropic-ai, Bytespider, CCBot, Meta-ExternalAgent, Google-Extended, LinkedInBot, SemrushBot, UptimeRobot), add them.
4. **Async bot tracking**: Ensure the bot tracking middleware uses `await` on the `httpx.post` call. Fire-and-forget calls may silently fail on serverless runtimes.

If none of these apply or BlueMonitor is not yet set up, proceed with the fresh install below.

## Important: Auto-detect the domain

Automatically detect the project's production domain from the codebase (check `.env`, `pyproject.toml`, or similar config files for `APP_URL`, `BASE_URL`, or domain references). Use the detected domain directly in the heartbeat URL — do NOT use placeholders like `yourapp.com`.

## 1. Health Endpoint (optional)

```python
@app.get("/api/health")
async def health():
    return {"status": "ok"}
```

BlueMonitor pings this every 5 minutes. If it responds with 200 under 3s → operational. Over 3s → slow. Error/timeout → down.

## 2. Heartbeat Push (recommended)

Push detailed health data to BlueMonitor on a schedule using APScheduler. This checks your database, cache, external APIs, and your own API endpoints.

```bash
pip install apscheduler httpx
```

**Requirements:**
- A BlueMonitor API key (create at https://www.bluemonitor.org/dashboard)
- The first heartbeat auto-registers the service and adds it to your watchlist

**Important: Auto-discover checks.** Scan the project for dependencies and routes to build a comprehensive heartbeat. Look for:
- **Database**: SQLAlchemy, databases, asyncpg, psycopg2, etc. → add a `SELECT 1` check
- **Redis/Cache**: redis-py, aioredis imports → add a `PING` check
- **External APIs**: discover ALL external dependencies, not just SDKs:
  - Scan for SDK imports (stripe, boto3, openai, twilio, etc.)
  - Scan for httpx/requests/aiohttp calls to external URLs — skip localhost, same-domain, and relative URLs
  - For each external API found, add a HEAD check to its base URL with a 5s timeout. Any HTTP response (even 404/421) = reachable = ok; only connection errors/timeouts = down
  - Name with `ext:` prefix: `ext:google-books`, `ext:openai`, `ext:stripe`
- **API endpoints**: scan route decorators (`@app.get`, `@router.get`) → add HTTP checks for key endpoints. **Exclude `/api/health`** — BlueMonitor already monitors it via pull check; including it creates a redundant check that often false-alarms.

```python
import os
import time
import httpx
from datetime import datetime
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from contextlib import asynccontextmanager

BLUEMONITOR_API_KEY = os.getenv("BLUEMONITOR_API_KEY")
BASE_URL = os.getenv("APP_URL", "http://localhost:8000")

async def check_external_api(client: httpx.AsyncClient, base_url: str):
    start = time.monotonic()
    try:
        await client.head(base_url, timeout=5)
        # Any HTTP response (even 404/421) means the API is reachable = ok
        # Only network errors or timeouts (caught below) mean it's down
        return {"status": "ok", "latency": round((time.monotonic() - start) * 1000)}
    except Exception:
        return {"status": "error", "latency": round((time.monotonic() - start) * 1000)}

async def check_endpoint(client: httpx.AsyncClient, url: str):
    start = time.monotonic()
    try:
        res = await client.get(url, timeout=5)
        return {
            "status": "ok" if res.is_success else "error",
            "latency": round((time.monotonic() - start) * 1000),
            "message": None if res.is_success else f"HTTP {res.status_code}",
        }
    except Exception as e:
        return {
            "status": "error",
            "latency": round((time.monotonic() - start) * 1000),
            "message": str(e),
        }

async def send_heartbeat():
    checks = {}

    # Infrastructure checks
    db_start = time.monotonic()
    try:
        await database.execute("SELECT 1")
        checks["database"] = {
            "status": "ok",
            "latency": round((time.monotonic() - db_start) * 1000),
        }
    except Exception as e:
        checks["database"] = {
            "status": "error",
            "latency": round((time.monotonic() - db_start) * 1000),
            "message": str(e),
        }

    # checks["redis"] = ...
    # checks["stripe"] = ...

    # API endpoint checks — add your key endpoints here
    async with httpx.AsyncClient() as client:
        # checks["api:/api/users"] = await check_endpoint(client, f"{BASE_URL}/api/users")
        # checks["api:/api/products"] = await check_endpoint(client, f"{BASE_URL}/api/products")

        # External API checks — add services your app calls
        # checks["ext:google-books"] = await check_external_api(client, "https://www.googleapis.com/books/v1/volumes?q=test&maxResults=1")
        # checks["ext:openai"] = await check_external_api(client, "https://api.openai.com")

        has_error = any(c["status"] == "error" for c in checks.values())

        await client.post(
            "https://www.bluemonitor.org/api/v1/heartbeat",
            headers={"Authorization": f"Bearer {BLUEMONITOR_API_KEY}"},
            json={
                "domain": "yourapp.com",
                "status": "error" if has_error else "ok",
                "timestamp": datetime.utcnow().isoformat(),
                "checks": checks,
            },
        )

@asynccontextmanager
async def lifespan(app):
    scheduler = AsyncIOScheduler()
    scheduler.add_job(send_heartbeat, "interval", minutes=5)
    scheduler.start()
    await send_heartbeat()  # Send on startup
    yield
    scheduler.shutdown()

app = FastAPI(lifespan=lifespan)
```

Add to `.env`:

```
BLUEMONITOR_API_KEY=bm_your_api_key
```

## 3. Status Badge

Replace `your-domain-com` with your domain (dots become dashes). Place the badge in your footer for maximum visibility.

```markdown
[![Status](https://www.bluemonitor.org/api/badge/your-domain-com)](https://www.bluemonitor.org/status/your-domain-com)
```

## Heartbeat Request Schema

POST `https://www.bluemonitor.org/api/v1/heartbeat`

Headers: `Authorization: Bearer bm_...`, `Content-Type: application/json`

```json
{
  "domain": "yourapp.com",
  "status": "ok",
  "timestamp": "2026-02-12T12:00:00.000Z",
  "checks": {
    "database": { "status": "ok", "latency": 5 },
    "redis": { "status": "ok", "latency": 2 },
    "ext:google-books": { "status": "ok", "latency": 180 },
    "api:/api/users": { "status": "ok", "latency": 45 }
  }
}
```

- `domain`: your service's production domain (auto-detect from project config)
- `status`: "ok" or "error"
- `checks`: object with dependency names as keys, each with `status`, `latency` (ms), optional `message`
- If BlueMonitor stops receiving heartbeats for 10 minutes, the service is marked as down

## 4. Bot Tracking (Pro)

Track which bots crawl your FastAPI app. Requires a Pro plan and API key.

Add bot detection middleware:

```python
import re
import os
import httpx
from starlette.middleware.base import BaseHTTPMiddleware

BOT_PATTERNS = [
    # Search engines
    (re.compile(r"Googlebot", re.I), "googlebot", "search_engine"),
    (re.compile(r"bingbot", re.I), "bingbot", "search_engine"),
    (re.compile(r"YandexBot", re.I), "yandexbot", "search_engine"),
    (re.compile(r"Baiduspider", re.I), "baiduspider", "search_engine"),
    (re.compile(r"DuckDuckBot", re.I), "duckduckbot", "search_engine"),
    (re.compile(r"Applebot", re.I), "applebot", "search_engine"),
    (re.compile(r"PetalBot", re.I), "petalbot", "search_engine"),
    (re.compile(r"Sogou", re.I), "sogoubot", "search_engine"),
    (re.compile(r"NaverBot", re.I), "naverbot", "search_engine"),
    (re.compile(r"Seznambot", re.I), "seznambot", "search_engine"),

    # AI crawlers
    (re.compile(r"GPTBot", re.I), "gptbot", "ai_crawler"),
    (re.compile(r"ChatGPT-User", re.I), "chatgpt-user", "ai_crawler"),
    (re.compile(r"OAI-SearchBot", re.I), "oai-searchbot", "ai_crawler"),
    (re.compile(r"ClaudeBot", re.I), "claudebot", "ai_crawler"),
    (re.compile(r"anthropic-ai", re.I), "anthropic-ai", "ai_crawler"),
    (re.compile(r"PerplexityBot", re.I), "perplexitybot", "ai_crawler"),
    (re.compile(r"Bytespider", re.I), "bytespider", "ai_crawler"),
    (re.compile(r"CCBot", re.I), "ccbot", "ai_crawler"),
    (re.compile(r"Meta-ExternalAgent", re.I), "meta-externalagent", "ai_crawler"),
    (re.compile(r"Google-Extended", re.I), "google-extended", "ai_crawler"),
    (re.compile(r"Amazonbot", re.I), "amazonbot", "ai_crawler"),
    (re.compile(r"cohere-ai", re.I), "cohere-ai", "ai_crawler"),
    (re.compile(r"DeepSeekBot", re.I), "deepseekbot", "ai_crawler"),
    (re.compile(r"YouBot", re.I), "youbot", "ai_crawler"),
    (re.compile(r"AI2Bot", re.I), "ai2bot", "ai_crawler"),
    (re.compile(r"Timpibot", re.I), "timpibot", "ai_crawler"),

    # Social
    (re.compile(r"Twitterbot", re.I), "twitterbot", "social"),
    (re.compile(r"facebookexternalhit", re.I), "facebookbot", "social"),
    (re.compile(r"LinkedInBot", re.I), "linkedinbot", "social"),
    (re.compile(r"Slackbot", re.I), "slackbot", "social"),
    (re.compile(r"Discordbot", re.I), "discordbot", "social"),
    (re.compile(r"TelegramBot", re.I), "telegrambot", "social"),
    (re.compile(r"WhatsApp", re.I), "whatsapp", "social"),
    (re.compile(r"Pinterestbot", re.I), "pinterestbot", "social"),

    # SEO
    (re.compile(r"AhrefsBot", re.I), "ahrefsbot", "seo"),
    (re.compile(r"SemrushBot", re.I), "semrushbot", "seo"),
    (re.compile(r"DotBot", re.I), "dotbot", "seo"),
    (re.compile(r"MJ12bot", re.I), "mj12bot", "seo"),
    (re.compile(r"DataForSeoBot", re.I), "dataforseobot", "seo"),
    (re.compile(r"Screaming Frog", re.I), "screamingfrog", "seo"),
    (re.compile(r"BLEXBot", re.I), "blexbot", "seo"),

    # Monitoring
    (re.compile(r"UptimeRobot", re.I), "uptimerobot", "monitoring"),
    (re.compile(r"Pingdom", re.I), "pingdom", "monitoring"),
    (re.compile(r"NewRelicPinger", re.I), "newrelicpinger", "monitoring"),
    (re.compile(r"Datadog", re.I), "datadoghq", "monitoring"),
    (re.compile(r"Site24x7", re.I), "site24x7", "monitoring"),
]

def identify_bot(ua: str):
    for pattern, name, category in BOT_PATTERNS:
        if pattern.search(ua):
            return {"name": name, "category": category}
    return None

class BotTrackingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        ua = request.headers.get("user-agent", "")
        bot = identify_bot(ua)
        if bot:
            try:
                async with httpx.AsyncClient() as client:
                    await client.post(
                        "https://www.bluemonitor.org/api/v1/bot-visits",
                        headers={"Authorization": f"Bearer {os.getenv('BLUEMONITOR_API_KEY')}"},
                        json={
                            "domain": "yourapp.com",
                            "visits": [{"bot_name": bot["name"], "bot_category": bot["category"], "path": str(request.url.path), "user_agent": ua}],
                        },
                        timeout=5,
                    )
            except Exception:
                pass
        return await call_next(request)

app.add_middleware(BotTrackingMiddleware)
```

- Requires Pro plan + `BLUEMONITOR_API_KEY` env variable
- View results in the BlueMonitor dashboard under "Bot Tracking"
