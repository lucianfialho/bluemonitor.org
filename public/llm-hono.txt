# BlueMonitor — Hono Setup Guide
# Version: 2.2
# Last-Updated: 2026-02-15
# Changelog: Enhanced external API auto-discovery with ext: naming convention

Add uptime monitoring, heartbeat push, and a status badge to your Hono app. Works on Cloudflare Workers, Deno, Bun, and Node.js.

Documentation: https://www.bluemonitor.org/docs/hono

## Update Notice (v2.2)

If this project already has BlueMonitor set up, check for these issues before adding anything new:

1. **External API reachability check**: If the heartbeat has `checkExternalAPI` that uses `res.ok` to determine status, fix it. Many APIs return non-2xx on their base URL (e.g. OpenAI → 421, Firestore → 404) but are fully operational. Change the logic to: any HTTP response = "ok" (reachable), only connection errors/timeouts = "error" (down).
2. **External API auto-discovery**: If the heartbeat only checks SDK imports (Stripe, OpenAI), also scan for `fetch`/`axios`/`got` calls to external URLs and add `ext:` checks for those too.
3. **await/waitUntil in bot tracking**: If the bot tracking middleware uses `fetch(...).catch(() => {})` without `await` or `waitUntil`, fix it. On Cloudflare Workers, use `c.executionCtx.waitUntil(promise)`. On other runtimes (Deno, Bun, Node), use `await` before the fetch call. Without this, bot visits silently fail because the promise is killed when the response returns.
4. **Bot patterns**: Compare the project's `BOT_PATTERNS` array against the list in Section 4 below. If missing newer bots (ChatGPT-User, anthropic-ai, Bytespider, CCBot, Meta-ExternalAgent, Google-Extended, LinkedInBot, SemrushBot, UptimeRobot), add them.

If none of these apply or BlueMonitor is not yet set up, proceed with the fresh install below.

## Important: Auto-detect the domain

Automatically detect the project's production domain from the codebase (check `wrangler.toml`, `package.json`, `.env` files, or similar). Use the detected domain directly in the heartbeat URL — do NOT use placeholders like `yourapp.com`.

## 1. Health Endpoint (optional)

```ts
import { Hono } from "hono";

const app = new Hono();

app.get("/api/health", (c) => {
  return c.json({ status: "ok" });
});

export default app;
```

BlueMonitor pings this every 5 minutes. If it responds with 200 under 3s → operational. Over 3s → slow. Error/timeout → down.

## 2. Heartbeat Push (recommended)

Push detailed health data to BlueMonitor on a schedule. This checks your database, cache, external APIs, and your own API endpoints.

**Requirements:**
- A BlueMonitor API key (create at https://www.bluemonitor.org/dashboard)
- The first heartbeat auto-registers the service and adds it to your watchlist

**Important: Auto-discover checks.** Scan the project for dependencies and routes to build a comprehensive heartbeat. Look for:
- **Database**: D1, Turso, Neon, or any SQL client → add a `SELECT 1` check
- **KV/Cache**: Cloudflare KV, Redis, Upstash imports → add a read check
- **External APIs**: discover ALL external dependencies, not just SDKs:
  - Scan for SDK imports (Stripe, SendGrid, AWS, OpenAI, Twilio, etc.)
  - Scan for fetch/axios/got calls to external URLs — skip localhost, same-domain, and relative URLs
  - For each external API found, add a HEAD check to its base URL with a 5s timeout. Any HTTP response (even 404/421) = reachable = ok; only connection errors/timeouts = down
  - Name with `ext:` prefix: `ext:google-books`, `ext:openai`, `ext:stripe`
- **API endpoints**: scan route definitions for GET handlers → add HTTP checks for key endpoints. **Exclude `/api/health`** — BlueMonitor already monitors it via pull check; including it creates a redundant check that often false-alarms.

### Cloudflare Workers

Add to `wrangler.toml`:

```toml
[triggers]
crons = ["*/5 * * * *"]
```

```ts
async function checkExternalAPI(baseUrl) {
  const start = Date.now();
  try {
    await fetch(baseUrl, { method: "HEAD", signal: AbortSignal.timeout(5000) });
    // Any HTTP response (even 404/421) means the API is reachable = ok
    // Only network errors or timeouts (caught below) mean it's down
    return { status: "ok", latency: Date.now() - start };
  } catch {
    return { status: "error", latency: Date.now() - start };
  }
}

async function checkEndpoint(url) {
  const start = Date.now();
  try {
    const res = await fetch(url);
    return { status: res.ok ? "ok" : "error", latency: Date.now() - start, message: res.ok ? undefined : `HTTP ${res.status}` };
  } catch (err) {
    return { status: "error", latency: Date.now() - start, message: String(err) };
  }
}

export default {
  fetch: app.fetch,

  async scheduled(event, env, ctx) {
    const checks = {};

    // Infrastructure checks
    const dbStart = Date.now();
    try {
      await env.DB.prepare("SELECT 1").run();
      checks.database = { status: "ok", latency: Date.now() - dbStart };
    } catch (err) {
      checks.database = { status: "error", latency: Date.now() - dbStart, message: String(err) };
    }

    // checks.kv = ...
    // checks.stripe = ...

    // API endpoint checks — add your key endpoints here
    // checks["api:/api/users"] = await checkEndpoint("https://yourapp.com/api/users");
    // checks["api:/api/products"] = await checkEndpoint("https://yourapp.com/api/products");

    // External API checks — add services your app calls
    // checks["ext:google-books"] = await checkExternalAPI("https://www.googleapis.com/books/v1/volumes?q=test&maxResults=1");
    // checks["ext:openai"] = await checkExternalAPI("https://api.openai.com");

    const hasError = Object.values(checks).some((c) => c.status === "error");

    await fetch(
      "https://www.bluemonitor.org/api/v1/heartbeat",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${env.BLUEMONITOR_API_KEY || process.env.BLUEMONITOR_API_KEY}`,
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          domain: "yourapp.com",
          status: hasError ? "error" : "ok",
          timestamp: new Date().toISOString(),
          checks,
        }),
      }
    );
  },
};
```

### Node.js / Bun / Deno

Use `setInterval` or a cron library:

```ts
async function checkExternalAPI(baseUrl) {
  const start = Date.now();
  try {
    await fetch(baseUrl, { method: "HEAD", signal: AbortSignal.timeout(5000) });
    // Any HTTP response (even 404/421) means the API is reachable = ok
    // Only network errors or timeouts (caught below) mean it's down
    return { status: "ok", latency: Date.now() - start };
  } catch {
    return { status: "error", latency: Date.now() - start };
  }
}

async function checkEndpoint(url) {
  const start = Date.now();
  try {
    const res = await fetch(url);
    return { status: res.ok ? "ok" : "error", latency: Date.now() - start, message: res.ok ? undefined : `HTTP ${res.status}` };
  } catch (err) {
    return { status: "error", latency: Date.now() - start, message: String(err) };
  }
}

async function sendHeartbeat() {
  const baseUrl = process.env.APP_URL || "http://localhost:3000";
  const checks = {};

  // Infrastructure checks
  const dbStart = Date.now();
  try {
    await db.execute("SELECT 1");
    checks.database = { status: "ok", latency: Date.now() - dbStart };
  } catch (err) {
    checks.database = { status: "error", latency: Date.now() - dbStart };
  }

  // checks.redis = ...

  // API endpoint checks — add your key endpoints here
  // checks["api:/api/users"] = await checkEndpoint(`${baseUrl}/api/users`);
  // checks["api:/api/products"] = await checkEndpoint(`${baseUrl}/api/products`);

  // External API checks — add services your app calls
  // checks["ext:google-books"] = await checkExternalAPI("https://www.googleapis.com/books/v1/volumes?q=test&maxResults=1");
  // checks["ext:openai"] = await checkExternalAPI("https://api.openai.com");

  const hasError = Object.values(checks).some((c) => c.status === "error");

  await fetch("https://www.bluemonitor.org/api/v1/heartbeat", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${process.env.BLUEMONITOR_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      domain: "yourapp.com",
      status: hasError ? "error" : "ok",
      timestamp: new Date().toISOString(),
      checks,
    }),
  });
}

setInterval(sendHeartbeat, 5 * 60 * 1000);
sendHeartbeat();
```

## 3. Status Badge

Replace `your-domain-com` with your domain (dots become dashes). Place the badge in your footer for maximum visibility.

```markdown
[![Status](https://www.bluemonitor.org/api/badge/your-domain-com)](https://www.bluemonitor.org/status/your-domain-com)
```

## Heartbeat Request Schema

POST `https://www.bluemonitor.org/api/v1/heartbeat`

Headers: `Authorization: Bearer bm_...`, `Content-Type: application/json`

```json
{
  "domain": "yourapp.com",
  "status": "ok",
  "timestamp": "2026-02-12T12:00:00.000Z",
  "checks": {
    "database": { "status": "ok", "latency": 5 },
    "redis": { "status": "ok", "latency": 2 },
    "ext:google-books": { "status": "ok", "latency": 180 },
    "api:/api/users": { "status": "ok", "latency": 45 }
  }
}
```

- `domain`: your service's production domain (auto-detect from project config)
- `status`: "ok" or "error"
- `checks`: object with dependency names as keys, each with `status`, `latency` (ms), optional `message`
- If BlueMonitor stops receiving heartbeats for 10 minutes, the service is marked as down

## 4. Bot Tracking (Pro)

Track which bots crawl your Hono app. Requires a Pro plan and API key.

Add bot detection middleware:

```ts
import { createMiddleware } from "hono/factory";

const BOT_PATTERNS = [
  // Search engines
  { pattern: /Googlebot/i, name: "googlebot", category: "search_engine" },
  { pattern: /bingbot/i, name: "bingbot", category: "search_engine" },
  { pattern: /YandexBot/i, name: "yandexbot", category: "search_engine" },
  { pattern: /Baiduspider/i, name: "baiduspider", category: "search_engine" },
  { pattern: /DuckDuckBot/i, name: "duckduckbot", category: "search_engine" },
  { pattern: /Applebot/i, name: "applebot", category: "search_engine" },
  { pattern: /PetalBot/i, name: "petalbot", category: "search_engine" },
  { pattern: /Sogou/i, name: "sogoubot", category: "search_engine" },
  { pattern: /NaverBot/i, name: "naverbot", category: "search_engine" },
  { pattern: /Seznambot/i, name: "seznambot", category: "search_engine" },

  // AI crawlers
  { pattern: /GPTBot/i, name: "gptbot", category: "ai_crawler" },
  { pattern: /ChatGPT-User/i, name: "chatgpt-user", category: "ai_crawler" },
  { pattern: /OAI-SearchBot/i, name: "oai-searchbot", category: "ai_crawler" },
  { pattern: /ClaudeBot/i, name: "claudebot", category: "ai_crawler" },
  { pattern: /anthropic-ai/i, name: "anthropic-ai", category: "ai_crawler" },
  { pattern: /PerplexityBot/i, name: "perplexitybot", category: "ai_crawler" },
  { pattern: /Bytespider/i, name: "bytespider", category: "ai_crawler" },
  { pattern: /CCBot/i, name: "ccbot", category: "ai_crawler" },
  { pattern: /Meta-ExternalAgent/i, name: "meta-externalagent", category: "ai_crawler" },
  { pattern: /Google-Extended/i, name: "google-extended", category: "ai_crawler" },
  { pattern: /Amazonbot/i, name: "amazonbot", category: "ai_crawler" },
  { pattern: /cohere-ai/i, name: "cohere-ai", category: "ai_crawler" },
  { pattern: /DeepSeekBot/i, name: "deepseekbot", category: "ai_crawler" },
  { pattern: /YouBot/i, name: "youbot", category: "ai_crawler" },
  { pattern: /AI2Bot/i, name: "ai2bot", category: "ai_crawler" },
  { pattern: /Timpibot/i, name: "timpibot", category: "ai_crawler" },

  // Social
  { pattern: /Twitterbot/i, name: "twitterbot", category: "social" },
  { pattern: /facebookexternalhit/i, name: "facebookbot", category: "social" },
  { pattern: /LinkedInBot/i, name: "linkedinbot", category: "social" },
  { pattern: /Slackbot/i, name: "slackbot", category: "social" },
  { pattern: /Discordbot/i, name: "discordbot", category: "social" },
  { pattern: /TelegramBot/i, name: "telegrambot", category: "social" },
  { pattern: /WhatsApp/i, name: "whatsapp", category: "social" },
  { pattern: /Pinterestbot/i, name: "pinterestbot", category: "social" },

  // SEO
  { pattern: /AhrefsBot/i, name: "ahrefsbot", category: "seo" },
  { pattern: /SemrushBot/i, name: "semrushbot", category: "seo" },
  { pattern: /DotBot/i, name: "dotbot", category: "seo" },
  { pattern: /MJ12bot/i, name: "mj12bot", category: "seo" },
  { pattern: /DataForSeoBot/i, name: "dataforseobot", category: "seo" },
  { pattern: /Screaming Frog/i, name: "screamingfrog", category: "seo" },
  { pattern: /BLEXBot/i, name: "blexbot", category: "seo" },

  // Monitoring
  { pattern: /UptimeRobot/i, name: "uptimerobot", category: "monitoring" },
  { pattern: /Pingdom/i, name: "pingdom", category: "monitoring" },
  { pattern: /NewRelicPinger/i, name: "newrelicpinger", category: "monitoring" },
  { pattern: /Datadog/i, name: "datadoghq", category: "monitoring" },
  { pattern: /Site24x7/i, name: "site24x7", category: "monitoring" },
];

function identifyBot(ua: string) {
  for (const bot of BOT_PATTERNS) {
    if (bot.pattern.test(ua)) return { name: bot.name, category: bot.category };
  }
  return null;
}

const botTracking = createMiddleware(async (c, next) => {
  const ua = c.req.header("user-agent") || "";
  const bot = identifyBot(ua);
  if (bot) {
    // IMPORTANT: In serverless/edge runtimes, unawaited fetches may be killed.
    // Use waitUntil on Cloudflare Workers, or await on other runtimes.
    const promise = fetch("https://www.bluemonitor.org/api/v1/bot-visits", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${c.env?.BLUEMONITOR_API_KEY || process.env.BLUEMONITOR_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        domain: "yourapp.com",
        visits: [{ bot_name: bot.name, bot_category: bot.category, path: new URL(c.req.url).pathname, user_agent: ua }],
      }),
    }).catch(() => {});
    if (c.executionCtx?.waitUntil) {
      c.executionCtx.waitUntil(promise);
    } else {
      await promise;
    }
  }
  await next();
});

app.use("*", botTracking);
```

- Requires Pro plan + `BLUEMONITOR_API_KEY` env variable
- View results in the BlueMonitor dashboard under "Bot Tracking"
