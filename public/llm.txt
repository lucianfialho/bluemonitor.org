# BlueMonitor — Status Badge Installation Guide

BlueMonitor is a real-time status monitoring service. The badge shows live status of any website: Operational (green), Slow (yellow), Down (red), or Pending (blue).

Badge endpoint: https://www.bluemonitor.org/api/badge/{slug}
Status page: https://www.bluemonitor.org/status/{slug}

The slug is the domain with dots replaced by hyphens. Examples:
- chatgpt → chat-openai-com
- google.com → google-com
- api.example.com → api-example-com

If the slug doesn't exist yet, the badge auto-registers the service as "Pending" for approval.

## Query Parameters

- `theme=dark` — Dark background variant (default: light)

## HTML

```html
<a href="https://www.bluemonitor.org/status/{slug}" target="_blank" rel="noopener">
  <img src="https://www.bluemonitor.org/api/badge/{slug}" alt="Status on BlueMonitor" height="36" />
</a>
```

## Markdown

```markdown
[![Status on BlueMonitor](https://www.bluemonitor.org/api/badge/{slug})](https://www.bluemonitor.org/status/{slug})
```

## React / Next.js

```tsx
function StatusBadge({ slug }: { slug: string }) {
  return (
    <a href={`https://www.bluemonitor.org/status/${slug}`} target="_blank" rel="noopener">
      <img src={`https://www.bluemonitor.org/api/badge/${slug}`} alt="Status on BlueMonitor" height={36} />
    </a>
  );
}
```

## Vue

```vue
<template>
  <a :href="`https://www.bluemonitor.org/status/${slug}`" target="_blank" rel="noopener">
    <img :src="`https://www.bluemonitor.org/api/badge/${slug}`" alt="Status on BlueMonitor" height="36" />
  </a>
</template>

<script setup>
defineProps({ slug: String });
</script>
```

## Svelte

```svelte
<script>
  export let slug;
</script>

<a href="https://www.bluemonitor.org/status/{slug}" target="_blank" rel="noopener">
  <img src="https://www.bluemonitor.org/api/badge/{slug}" alt="Status on BlueMonitor" height="36" />
</a>
```

## Health Endpoint

Create a public health endpoint so BlueMonitor can check your service with real diagnostics — not just "is the server alive" but "is the database connected, are external APIs reachable, is everything actually working."

### Route: GET /api/health

The endpoint must:
1. Be publicly accessible (no auth required)
2. Return JSON with the schema below
3. Check database connectivity and critical dependencies
4. Respond within 3 seconds (responses over 3s are marked as "slow")
5. Return HTTP 200 for "ok" or "degraded", HTTP 503 for "error"
6. NEVER expose sensitive data (connection strings, credentials, internal IPs, query results)
7. Only return status ("ok" or "error"), latency in ms, and optional error message

### Security

The health endpoint is public by design (same pattern as Kubernetes liveness/readiness probes). It only returns operational status and latency — no sensitive data.

To restrict access to BlueMonitor only, check the User-Agent header:

```ts
export async function GET(req: Request) {
  const ua = req.headers.get("user-agent") || "";
  if (!ua.includes("BlueMonitor")) {
    return Response.json({ error: "Forbidden" }, { status: 403 });
  }
  // ... run checks
}
```

This is optional. BlueMonitor always sends `User-Agent: BlueMonitor/1.0 (status check)`.

### Response Schema

```json
{
  "status": "ok" | "degraded" | "error",
  "timestamp": "2026-02-12T12:00:00.000Z",
  "version": "1.0.0",
  "checks": {
    "database": { "status": "ok", "latency": 5 },
    "redis": { "status": "ok", "latency": 2 },
    "stripe": { "status": "ok", "latency": 120 }
  }
}
```

**Status values:**
- `"ok"` — everything is healthy
- `"degraded"` — service works but something is slow or partially failing (BlueMonitor marks as "slow")
- `"error"` — critical failure, service is broken (BlueMonitor marks as "down")

**Rules:**
- If ANY check has `"status": "error"` → overall status must be `"error"`
- If ANY check has `"status": "error"` but service still works → overall can be `"degraded"`
- `latency` is in milliseconds, measured per check
- `checks` object: keys are dependency names, values have `status` and optional `latency`/`message`

### Next.js (App Router)

Create `app/api/health/route.ts`:

```ts
import { db } from "@/lib/db"; // adjust to your setup

async function checkDependency(name: string, fn: () => Promise<void>) {
  const start = Date.now();
  try {
    await fn();
    return { status: "ok" as const, latency: Date.now() - start };
  } catch (err) {
    return {
      status: "error" as const,
      latency: Date.now() - start,
      message: err instanceof Error ? err.message : "Unknown error",
    };
  }
}

export async function GET() {
  const checks = {
    database: await checkDependency("database", async () => {
      await db`SELECT 1`;
    }),
    // Add more checks for your dependencies:
    // redis: await checkDependency("redis", async () => { await redis.ping(); }),
    // stripe: await checkDependency("stripe", async () => { await stripe.balance.retrieve(); }),
  };

  const hasError = Object.values(checks).some((c) => c.status === "error");
  const status = hasError ? "error" : "ok";

  return Response.json(
    {
      status,
      timestamp: new Date().toISOString(),
      checks,
    },
    { status: hasError ? 503 : 200 }
  );
}
```

### Express

```ts
app.get("/api/health", async (req, res) => {
  const checks: Record<string, { status: string; latency: number; message?: string }> = {};

  // Database check
  const dbStart = Date.now();
  try {
    await db.query("SELECT 1");
    checks.database = { status: "ok", latency: Date.now() - dbStart };
  } catch (err) {
    checks.database = { status: "error", latency: Date.now() - dbStart, message: err.message };
  }

  // Add more checks as needed

  const hasError = Object.values(checks).some((c) => c.status === "error");
  const status = hasError ? "error" : "ok";

  res.status(hasError ? 503 : 200).json({
    status,
    timestamp: new Date().toISOString(),
    checks,
  });
});
```

### Hono

```ts
app.get("/api/health", async (c) => {
  const checks: Record<string, { status: string; latency: number; message?: string }> = {};

  const dbStart = Date.now();
  try {
    await db.execute("SELECT 1");
    checks.database = { status: "ok", latency: Date.now() - dbStart };
  } catch (err) {
    checks.database = { status: "error", latency: Date.now() - dbStart, message: String(err) };
  }

  const hasError = Object.values(checks).some((c) => c.status === "error");
  const status = hasError ? "error" : "ok";

  return c.json({ status, timestamp: new Date().toISOString(), checks }, hasError ? 503 : 200);
});
```

### FastAPI

```python
from datetime import datetime
import time

@app.get("/api/health")
async def health():
    checks = {}

    # Database check
    db_start = time.monotonic()
    try:
        await database.execute("SELECT 1")
        checks["database"] = {"status": "ok", "latency": round((time.monotonic() - db_start) * 1000)}
    except Exception as e:
        checks["database"] = {"status": "error", "latency": round((time.monotonic() - db_start) * 1000), "message": str(e)}

    has_error = any(c["status"] == "error" for c in checks.values())
    status = "error" if has_error else "ok"

    from fastapi.responses import JSONResponse
    return JSONResponse(
        content={"status": status, "timestamp": datetime.utcnow().isoformat(), "checks": checks},
        status_code=503 if has_error else 200,
    )
```

After creating the health endpoint, add a status badge to your site so users can see your service status in real-time. See the badge section above.

## Push Monitoring (Heartbeat)

Instead of exposing a public `/api/health` endpoint for BlueMonitor to pull, your service can **push** heartbeats directly. This is more secure (no public health endpoint needed) and works well for services behind firewalls or private networks.

**How it works:**
1. Your service runs health checks internally
2. It POSTs the results to BlueMonitor every few minutes
3. If BlueMonitor stops receiving heartbeats for 10 minutes, the service is marked as down

**Requirements:**
- A BlueMonitor API key (create one from the dashboard)
- The service must already be in your watchlist (no auto-creation)

### Endpoint: POST /api/v1/heartbeat?domain={your-domain}

**Headers:**
- `Authorization: Bearer bm_your_api_key`
- `Content-Type: application/json`

**Body:** Same schema as the health endpoint response:

```json
{
  "status": "ok",
  "timestamp": "2026-02-12T12:00:00.000Z",
  "checks": {
    "database": { "status": "ok", "latency": 5 },
    "redis": { "status": "ok", "latency": 2 }
  }
}
```

**Response:**

```json
{
  "ok": true,
  "service": "My App",
  "status": "up",
  "response_time": 5,
  "checked_at": "2026-02-12T12:00:00.000Z"
}
```

### Next.js (Vercel Cron + Heartbeat)

Create `app/api/cron/heartbeat/route.ts`:

```ts
import { db } from "@/lib/db"; // adjust to your setup

async function checkDependency(name: string, fn: () => Promise<void>) {
  const start = Date.now();
  try {
    await fn();
    return { status: "ok" as const, latency: Date.now() - start };
  } catch (err) {
    return {
      status: "error" as const,
      latency: Date.now() - start,
      message: err instanceof Error ? err.message : "Unknown error",
    };
  }
}

export async function GET() {
  const checks = {
    database: await checkDependency("database", async () => {
      await db`SELECT 1`;
    }),
  };

  const hasError = Object.values(checks).some((c) => c.status === "error");
  const status = hasError ? "error" : "ok";

  // Push heartbeat to BlueMonitor
  await fetch("https://www.bluemonitor.org/api/v1/heartbeat?domain=myapp.com", {
    method: "POST",
    headers: {
      "Authorization": "Bearer bm_your_api_key",
      "Content-Type": "application/json",
    },
    body: JSON.stringify({ status, timestamp: new Date().toISOString(), checks }),
  });

  return Response.json({ ok: true });
}
```

Add to `vercel.json`:

```json
{
  "crons": [{ "path": "/api/cron/heartbeat", "schedule": "*/5 * * * *" }]
}
```

### Node.js (setInterval)

```ts
async function sendHeartbeat() {
  // Run your health checks
  const checks: Record<string, { status: string; latency: number }> = {};

  const dbStart = Date.now();
  try {
    await db.query("SELECT 1");
    checks.database = { status: "ok", latency: Date.now() - dbStart };
  } catch {
    checks.database = { status: "error", latency: Date.now() - dbStart };
  }

  const hasError = Object.values(checks).some((c) => c.status === "error");

  await fetch("https://www.bluemonitor.org/api/v1/heartbeat?domain=myapp.com", {
    method: "POST",
    headers: {
      "Authorization": "Bearer bm_your_api_key",
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      status: hasError ? "error" : "ok",
      timestamp: new Date().toISOString(),
      checks,
    }),
  });
}

// Send heartbeat every 5 minutes
setInterval(sendHeartbeat, 5 * 60 * 1000);
sendHeartbeat(); // Send immediately on startup
```

### curl (testing)

```bash
curl -X POST "https://www.bluemonitor.org/api/v1/heartbeat?domain=myapp.com" \
  -H "Authorization: Bearer bm_your_api_key" \
  -H "Content-Type: application/json" \
  -d '{"status":"ok","checks":{"database":{"status":"ok","latency":5}}}'
```

## Common Slugs

- chatgpt → `chatgpt`
- claude → `claude`
- github → `github`
- vercel → `vercel`
- openai → `openai`
- google → `google`
- stripe → `stripe`
- aws → `aws`

Full list: https://www.bluemonitor.org/sitemap.xml

## Badge Generator

Interactive badge generator with live preview and copy-paste code:
https://www.bluemonitor.org/badge

## API Reference

### GET /api/badge/{slug}
Returns a PNG image (280x36) with the current status of the service.
Cache: 5 minutes (s-maxage=300).

### GET /api/check/{domain}
Returns JSON with real-time status check result.
Response: `{ status: "up"|"down"|"slow", responseTime: number, statusCode: number, checkedAt: string }`

### GET /api/status-history/{slug}
Returns JSON array with the last 24 hours of status checks.
Response: `[{ status, response_time, status_code, checked_at }]`
