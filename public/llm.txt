# BlueMonitor — Monitoring Setup Guide
# Version: 2.2
# Last-Updated: 2026-02-15
# Changelog: Enhanced external API auto-discovery with ext: naming convention

BlueMonitor is a real-time status monitoring service. Add a health endpoint, push heartbeats, and embed a status badge.

Documentation: https://www.bluemonitor.org/docs

## IMPORTANT: Detect the framework and fetch the right guide

First, detect which framework this project uses (check `package.json`, `requirements.txt`, `Gemfile`, `composer.json`, or project structure). Then **fetch and follow** the matching guide below — it contains the full code, migration notices, and framework-specific instructions. Do NOT use only this generic file if a framework guide exists.

- **Next.js** (App Router): fetch https://www.bluemonitor.org/llm-nextjs.txt
- **Express**: fetch https://www.bluemonitor.org/llm-express.txt
- **Hono** (Cloudflare Workers, Deno, Bun): fetch https://www.bluemonitor.org/llm-hono.txt
- **FastAPI**: fetch https://www.bluemonitor.org/llm-fastapi.txt
- **Rails**: fetch https://www.bluemonitor.org/llm-rails.txt
- **Laravel**: fetch https://www.bluemonitor.org/llm-laravel.txt

If the framework is not listed above, continue with the generic instructions below.

## Update Notice (v2.2)

If this project already has BlueMonitor set up (look for existing heartbeat routes, bot tracking middleware, or `BLUEMONITOR_API_KEY` in env files), check for these issues before adding anything new:

1. **External API reachability check**: If the heartbeat has `checkExternalAPI` (or similar) that uses `res.ok` to determine status, fix it. Many APIs return non-2xx on their base URL (e.g. OpenAI → 421, Firestore → 404) but are fully operational. Change the logic to: any HTTP response = "ok" (reachable), only connection errors/timeouts = "error" (down).
2. **External API auto-discovery**: If the heartbeat only checks SDK imports (Stripe, SendGrid), also scan for `fetch`/`axios`/`got` calls to external URLs and add `ext:` checks for those too.
3. **await in bot tracking**: If the bot tracking code uses `fetch(...).catch(() => {})` without `await`, add `await`. On serverless/edge runtimes, unawaited promises are killed when the response returns, causing bot visits to silently fail.
4. **Bot patterns**: Compare the project's bot patterns against the list in Section 4 below. If missing newer bots (ChatGPT-User, anthropic-ai, Bytespider, CCBot, Meta-ExternalAgent, Google-Extended, LinkedInBot, SemrushBot, UptimeRobot), add them.
5. **Next.js 16+ only**: If using Next.js 16+, `middleware.ts` must be renamed to `proxy.ts` and the export from `middleware` to `proxy`. See the Next.js-specific guide for details.

If none of these apply or BlueMonitor is not yet set up, proceed with the fresh install below.

## Important: Auto-detect the domain

When generating code, automatically detect the project's production domain from the codebase (check `vercel.json`, `package.json` homepage field, `.env` files for `NEXT_PUBLIC_URL`, `APP_URL`, `VERCEL_PROJECT_PRODUCTION_URL`, or similar). Use the detected domain directly in the heartbeat URL — do NOT ask the user or use placeholders.

## How BlueMonitor Works

**Uptime monitoring (pull):** We ping your service every 5 minutes and track response time and status code. Optionally add a `GET /api/health` endpoint that returns `{ "status": "ok" }`.

**Heartbeat push:** Your service pushes detailed health data (database, cache, external APIs, and your own API endpoints) to BlueMonitor on a schedule via `POST /api/v1/heartbeat`. No public endpoint needed. If we stop receiving heartbeats for 10 minutes, the service is marked as down.

## Quick Start (any framework)

### 1. Health Endpoint (optional)

Create a `GET /api/health` route that returns:

```json
{ "status": "ok" }
```

- Return HTTP 200 for healthy, HTTP 503 for unhealthy
- Respond within 3 seconds (over 3s = marked as "slow")

### 2. Heartbeat Push (recommended)

POST to `https://www.bluemonitor.org/api/v1/heartbeat`

Headers: `Authorization: Bearer bm_your_api_key`, `Content-Type: application/json`

```json
{
  "domain": "yourapp.com",
  "status": "ok",
  "timestamp": "2026-02-12T12:00:00.000Z",
  "checks": {
    "database": { "status": "ok", "latency": 5 },
    "redis": { "status": "ok", "latency": 2 },
    "ext:google-books": { "status": "ok", "latency": 180 },
    "api:/api/users": { "status": "ok", "latency": 45 },
    "api:/api/products": { "status": "ok", "latency": 120 }
  }
}
```

Requirements:
- A BlueMonitor API key (create at https://www.bluemonitor.org/dashboard)
- Send heartbeats every 5 minutes via cron or scheduler
- The first heartbeat auto-registers the service and adds it to your watchlist

**Important: Auto-discover checks.** When generating heartbeat code, scan the project for dependencies and routes to build comprehensive checks:
- **Database**: any ORM or SQL client → add a `SELECT 1` check
- **Redis/Cache**: Redis or cache client imports → add a `PING` check
- **External APIs**: discover ALL external dependencies, not just SDKs:
  - Scan for SDK imports (Stripe, SendGrid, AWS, OpenAI, Twilio, etc.)
  - Scan for fetch/axios/got/httpx/requests calls to external URLs — skip localhost, same-domain, and relative URLs
  - For each external API found, add a HEAD check to its base URL with a 5s timeout. Any HTTP response (even 404/421) = reachable = ok; only connection errors/timeouts = down
  - Name with `ext:` prefix: `ext:google-books`, `ext:openai`, `ext:stripe`
- **API endpoints**: scan route files for GET handlers → add HTTP checks (fetch internally and verify 200 response). **Exclude `/api/health`** — BlueMonitor already monitors it via pull check; including it creates a redundant check that often false-alarms.

Check names are free-form strings: `"database"`, `"redis"` for infra; `"api:/api/users"` for internal endpoints; `"ext:google-books"`, `"ext:openai"` for external APIs.

### 3. Status Badge

Badge endpoint: `https://www.bluemonitor.org/api/badge/{slug}`
Status page: `https://www.bluemonitor.org/status/{slug}`

The slug is the domain with dots replaced by hyphens (e.g., `yourapp.com` → `yourapp-com`).

#### HTML

```html
<a href="https://www.bluemonitor.org/status/{slug}" target="_blank" rel="noopener">
  <img src="https://www.bluemonitor.org/api/badge/{slug}" alt="Status on BlueMonitor" height="36" />
</a>
```

#### Markdown

```markdown
[![Status](https://www.bluemonitor.org/api/badge/{slug})](https://www.bluemonitor.org/status/{slug})
```

#### React / Next.js

```tsx
function StatusBadge({ slug }: { slug: string }) {
  return (
    <a href={`https://www.bluemonitor.org/status/${slug}`} target="_blank" rel="noopener">
      <img src={`https://www.bluemonitor.org/api/badge/${slug}`} alt="Status on BlueMonitor" height={36} />
    </a>
  );
}
```

**Placement:** Place the status badge in the footer of the app/site for maximum visibility.

## Badge Parameters

- `theme=dark` — Dark background variant (default: light)
- If the slug doesn't exist yet, the badge auto-registers the service as "Pending"

## API Reference

Full API docs: https://www.bluemonitor.org/docs/api

- `GET /api/v1/status/:slug` — Get status of a service
- `GET /api/v1/services` — List all monitored services
- `GET /api/v1/incidents` — Get recent incidents
- `POST /api/v1/heartbeat` — Push heartbeat (requires API key, domain in body)
- `GET /api/badge/:slug` — Status badge PNG image

## Common Slugs

- chatgpt → `chatgpt`
- claude → `claude`
- github → `github`
- vercel → `vercel`
- stripe → `stripe`

Full list: https://www.bluemonitor.org/sitemap.xml

## 4. Bot Tracking (Pro)

Track which bots and crawlers visit your site. Requires a Pro plan and API key.

POST to `https://www.bluemonitor.org/api/v1/bot-visits`

Headers: `Authorization: Bearer bm_your_api_key`, `Content-Type: application/json`

```json
{
  "domain": "yourapp.com",
  "visits": [
    {
      "bot_name": "googlebot",
      "bot_category": "search_engine",
      "path": "/about",
      "user_agent": "Googlebot/2.1 (+http://www.google.com/bot.html)"
    }
  ]
}
```

Known bot names: googlebot, bingbot, yandexbot, baiduspider, duckduckbot, gptbot, chatgpt-user, claudebot, anthropic-ai, perplexitybot, bytespider, ccbot, meta-externalagent, google-extended, twitterbot, facebookbot, linkedinbot, slackbot, discordbot, telegrambot, ahrefsbot, semrushbot, dotbot, mj12bot, uptimerobot, pingdom.

Categories: search_engine, ai_crawler, social, seo, monitoring.

### Generic bot detection (any framework)

Detect bots by user-agent and report visits:

```js
const BOT_PATTERNS = [
  { pattern: /Googlebot/i, name: "googlebot", category: "search_engine" },
  { pattern: /bingbot/i, name: "bingbot", category: "search_engine" },
  { pattern: /GPTBot/i, name: "gptbot", category: "ai_crawler" },
  { pattern: /ChatGPT-User/i, name: "chatgpt-user", category: "ai_crawler" },
  { pattern: /ClaudeBot/i, name: "claudebot", category: "ai_crawler" },
  { pattern: /anthropic-ai/i, name: "anthropic-ai", category: "ai_crawler" },
  { pattern: /PerplexityBot/i, name: "perplexitybot", category: "ai_crawler" },
  { pattern: /Bytespider/i, name: "bytespider", category: "ai_crawler" },
  { pattern: /CCBot/i, name: "ccbot", category: "ai_crawler" },
  { pattern: /Meta-ExternalAgent/i, name: "meta-externalagent", category: "ai_crawler" },
  { pattern: /Google-Extended/i, name: "google-extended", category: "ai_crawler" },
  { pattern: /Twitterbot/i, name: "twitterbot", category: "social" },
  { pattern: /facebookexternalhit/i, name: "facebookbot", category: "social" },
  { pattern: /LinkedInBot/i, name: "linkedinbot", category: "social" },
  { pattern: /AhrefsBot/i, name: "ahrefsbot", category: "seo" },
  { pattern: /SemrushBot/i, name: "semrushbot", category: "seo" },
  { pattern: /UptimeRobot/i, name: "uptimerobot", category: "monitoring" },
];

function identifyBot(ua) {
  for (const bot of BOT_PATTERNS) {
    if (bot.pattern.test(ua)) return { name: bot.name, category: bot.category };
  }
  return null;
}

// In your request handler, check user-agent and report:
// Preferred: use waitUntil (Next.js, Cloudflare Workers) to send without blocking the response.
// Fallback: await the fetch — unawaited promises may be killed in serverless/edge runtimes.
async function handleRequest(req) {
  const ua = req.headers["user-agent"] || "";
  const bot = identifyBot(ua);
  if (bot) {
    await fetch("https://www.bluemonitor.org/api/v1/bot-visits", {
      method: "POST",
      headers: {
        Authorization: `Bearer ${process.env.BLUEMONITOR_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        domain: "yourapp.com",
        visits: [{ bot_name: bot.name, bot_category: bot.category, path: req.url, user_agent: ua }],
      }),
    }).catch(() => {});
  }
}
```

- Max 100 visits per batch
- The first report auto-creates the tracking entry
- View results in the BlueMonitor dashboard under "Bot Tracking"
