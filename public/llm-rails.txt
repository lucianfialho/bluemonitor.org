# BlueMonitor — Rails Setup Guide
# Version: 2.2
# Last-Updated: 2026-02-15
# Changelog: Enhanced external API auto-discovery with ext: naming convention

Add uptime monitoring, heartbeat push, and a status badge to your Rails app.

Documentation: https://www.bluemonitor.org/docs/rails

## Update Notice (v2.2)

If this project already has BlueMonitor set up, check for these issues before adding anything new:

1. **External API reachability check**: If the heartbeat has `check_external_api` that checks `res.is_a?(Net::HTTPSuccess)`, fix it. Many APIs return non-2xx on their base URL (e.g. OpenAI → 421, Firestore → 404) but are fully operational. Change the logic to: any HTTP response = "ok" (reachable), only connection errors/timeouts = "error" (down).
2. **External API auto-discovery**: If the heartbeat only checks SDK imports (Stripe, AWS), also scan for HTTParty/Faraday/Net::HTTP calls to external URLs and add `ext:` checks for those too.
3. **Bot patterns**: Compare the project's bot patterns against the list in Section 4 below. If missing newer bots (ChatGPT-User, anthropic-ai, Bytespider, CCBot, Meta-ExternalAgent, Google-Extended, LinkedInBot, SemrushBot, UptimeRobot), add them.
4. **Background job for bot tracking**: If bot visits are sent inline (blocking the request), consider moving to a background job (Sidekiq, ActiveJob) for better performance.

If none of these apply or BlueMonitor is not yet set up, proceed with the fresh install below.

## Important: Auto-detect the domain

Automatically detect the project's production domain from the codebase (check `.env`, `config/environments/production.rb` for `host`, or similar). Use the detected domain directly in the heartbeat URL — do NOT use placeholders like `yourapp.com`.

## 1. Health Endpoint (optional)

Add to `config/routes.rb`:

```ruby
get "/api/health", to: "health#show"
```

Create `app/controllers/health_controller.rb`:

```ruby
class HealthController < ApplicationController
  skip_before_action :authenticate_user!, raise: false

  def show
    render json: { status: "ok" }
  end
end
```

BlueMonitor pings this every 5 minutes. If it responds with 200 under 3s → operational. Over 3s → slow. Error/timeout → down.

## 2. Heartbeat Push (recommended)

Push detailed health data to BlueMonitor using a recurring Sidekiq job. This checks your database, cache, external APIs, and your own API endpoints.

```ruby
gem "sidekiq-cron"
```

**Requirements:**
- A BlueMonitor API key (create at https://www.bluemonitor.org/dashboard)
- The first heartbeat auto-registers the service and adds it to your watchlist

**Important: Auto-discover checks.** Scan the project for dependencies and routes to build a comprehensive heartbeat. Look for:
- **Database**: ActiveRecord, Sequel, etc. → add a `SELECT 1` check
- **Redis/Cache**: Redis, Sidekiq (implies Redis) → add a `PING` check
- **External APIs**: discover ALL external dependencies, not just SDKs:
  - Scan for SDK imports (Stripe, AWS SDK, OpenAI, Twilio, etc.)
  - Scan for HTTParty/Faraday/Net::HTTP calls to external URLs — skip localhost, same-domain, and relative URLs
  - For each external API found, add a HEAD check to its base URL with a 5s timeout. Any HTTP response (even 404/421) = reachable = ok; only connection errors/timeouts = down
  - Name with `ext:` prefix: `ext:google-books`, `ext:openai`, `ext:stripe`
- **API endpoints**: scan `config/routes.rb` for GET routes → add HTTP checks for key endpoints. **Exclude `/api/health`** — BlueMonitor already monitors it via pull check; including it creates a redundant check that often false-alarms.

Create `app/jobs/heartbeat_job.rb`:

```ruby
class HeartbeatJob < ApplicationJob
  queue_as :default

  def perform
    checks = {}
    base_url = ENV.fetch("APP_URL", "http://localhost:3000")

    # Infrastructure checks
    check_timing(:database, checks) { ActiveRecord::Base.connection.execute("SELECT 1") }
    check_timing(:redis, checks) { Redis.current.ping }
    # check_timing(:stripe, checks) { Stripe::Balance.retrieve }

    # API endpoint checks — add your key routes here
    # check_endpoint("api:/api/users", "#{base_url}/api/users", checks)
    # check_endpoint("api:/api/products", "#{base_url}/api/products", checks)

    # External API checks — add services your app calls
    # check_external_api("ext:google-books", "https://www.googleapis.com/books/v1/volumes?q=test&maxResults=1", checks)
    # check_external_api("ext:openai", "https://api.openai.com", checks)

    has_error = checks.values.any? { |c| c[:status] == "error" }

    uri = URI("https://www.bluemonitor.org/api/v1/heartbeat")
    Net::HTTP.post(
      uri,
      {
        domain: "yourapp.com",
        status: has_error ? "error" : "ok",
        timestamp: Time.now.utc.iso8601,
        checks: checks
      }.to_json,
      "Authorization" => "Bearer #{ENV['BLUEMONITOR_API_KEY']}",
      "Content-Type" => "application/json"
    )
  end

  private

  def check_timing(name, checks)
    start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    begin
      yield
      checks[name] = { status: "ok", latency: ms_since(start) }
    rescue => e
      checks[name] = { status: "error", latency: ms_since(start), message: e.message }
    end
  end

  def check_external_api(name, base_url, checks)
    start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    uri = URI(base_url)
    # Any HTTP response (even 404/421) means the API is reachable = ok
    # Only network errors or timeouts (caught below) mean it's down
    Net::HTTP.start(uri.host, uri.port, use_ssl: true, read_timeout: 5) { |h| h.head(uri.path.empty? ? "/" : uri.path) }
    checks[name] = { status: "ok", latency: ms_since(start) }
  rescue => e
    checks[name] = { status: "error", latency: ms_since(start) }
  end

  def check_endpoint(name, url, checks)
    start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    begin
      res = Net::HTTP.get_response(URI(url))
      checks[name] = {
        status: res.is_a?(Net::HTTPSuccess) ? "ok" : "error",
        latency: ms_since(start),
        message: res.is_a?(Net::HTTPSuccess) ? nil : "HTTP #{res.code}"
      }
    rescue => e
      checks[name] = { status: "error", latency: ms_since(start), message: e.message }
    end
  end

  def ms_since(start)
    ((Process.clock_gettime(Process::CLOCK_MONOTONIC) - start) * 1000).round
  end
end
```

Add to `config/initializers/sidekiq_cron.rb`:

```ruby
Sidekiq::Cron::Job.create(
  name: "BlueMonitor heartbeat",
  cron: "*/5 * * * *",
  class: "HeartbeatJob"
)
```

Add to `.env`:

```
BLUEMONITOR_API_KEY=bm_your_api_key
```

## 3. Status Badge

Replace `your-domain-com` with your domain (dots become dashes). Place the badge in your footer for maximum visibility.

### ERB

```erb
<a href="https://www.bluemonitor.org/status/your-domain-com" target="_blank" rel="noopener">
  <img src="https://www.bluemonitor.org/api/badge/your-domain-com" alt="Status on BlueMonitor" height="36" />
</a>
```

### Markdown (README.md)

```markdown
[![Status](https://www.bluemonitor.org/api/badge/your-domain-com)](https://www.bluemonitor.org/status/your-domain-com)
```

## Heartbeat Request Schema

POST `https://www.bluemonitor.org/api/v1/heartbeat`

Headers: `Authorization: Bearer bm_...`, `Content-Type: application/json`

```json
{
  "domain": "yourapp.com",
  "status": "ok",
  "timestamp": "2026-02-12T12:00:00.000Z",
  "checks": {
    "database": { "status": "ok", "latency": 5 },
    "redis": { "status": "ok", "latency": 2 },
    "ext:google-books": { "status": "ok", "latency": 180 },
    "api:/api/users": { "status": "ok", "latency": 45 }
  }
}
```

- `domain`: your service's production domain (auto-detect from project config)
- `status`: "ok" or "error"
- `checks`: object with dependency names as keys, each with `status`, `latency` (ms), optional `message`
- If BlueMonitor stops receiving heartbeats for 10 minutes, the service is marked as down

## 4. Bot Tracking (Pro)

Track which bots crawl your Rails app. Requires a Pro plan and API key.

Create `app/middleware/bot_tracking_middleware.rb`:

```ruby
class BotTrackingMiddleware
  BOT_PATTERNS = [
    # Search engines
    [/Googlebot/i, "googlebot", "search_engine"],
    [/bingbot/i, "bingbot", "search_engine"],
    [/YandexBot/i, "yandexbot", "search_engine"],
    [/Baiduspider/i, "baiduspider", "search_engine"],
    [/DuckDuckBot/i, "duckduckbot", "search_engine"],
    [/Applebot/i, "applebot", "search_engine"],
    [/PetalBot/i, "petalbot", "search_engine"],
    [/Sogou/i, "sogoubot", "search_engine"],
    [/NaverBot/i, "naverbot", "search_engine"],
    [/Seznambot/i, "seznambot", "search_engine"],

    # AI crawlers
    [/GPTBot/i, "gptbot", "ai_crawler"],
    [/ChatGPT-User/i, "chatgpt-user", "ai_crawler"],
    [/OAI-SearchBot/i, "oai-searchbot", "ai_crawler"],
    [/ClaudeBot/i, "claudebot", "ai_crawler"],
    [/anthropic-ai/i, "anthropic-ai", "ai_crawler"],
    [/PerplexityBot/i, "perplexitybot", "ai_crawler"],
    [/Bytespider/i, "bytespider", "ai_crawler"],
    [/CCBot/i, "ccbot", "ai_crawler"],
    [/Meta-ExternalAgent/i, "meta-externalagent", "ai_crawler"],
    [/Google-Extended/i, "google-extended", "ai_crawler"],
    [/Amazonbot/i, "amazonbot", "ai_crawler"],
    [/cohere-ai/i, "cohere-ai", "ai_crawler"],
    [/DeepSeekBot/i, "deepseekbot", "ai_crawler"],
    [/YouBot/i, "youbot", "ai_crawler"],
    [/AI2Bot/i, "ai2bot", "ai_crawler"],
    [/Timpibot/i, "timpibot", "ai_crawler"],

    # Social
    [/Twitterbot/i, "twitterbot", "social"],
    [/facebookexternalhit/i, "facebookbot", "social"],
    [/LinkedInBot/i, "linkedinbot", "social"],
    [/Slackbot/i, "slackbot", "social"],
    [/Discordbot/i, "discordbot", "social"],
    [/TelegramBot/i, "telegrambot", "social"],
    [/WhatsApp/i, "whatsapp", "social"],
    [/Pinterestbot/i, "pinterestbot", "social"],

    # SEO
    [/AhrefsBot/i, "ahrefsbot", "seo"],
    [/SemrushBot/i, "semrushbot", "seo"],
    [/DotBot/i, "dotbot", "seo"],
    [/MJ12bot/i, "mj12bot", "seo"],
    [/DataForSeoBot/i, "dataforseobot", "seo"],
    [/Screaming Frog/i, "screamingfrog", "seo"],
    [/BLEXBot/i, "blexbot", "seo"],

    # Monitoring
    [/UptimeRobot/i, "uptimerobot", "monitoring"],
    [/Pingdom/i, "pingdom", "monitoring"],
    [/NewRelicPinger/i, "newrelicpinger", "monitoring"],
    [/Datadog/i, "datadoghq", "monitoring"],
    [/Site24x7/i, "site24x7", "monitoring"],
  ].freeze

  def initialize(app)
    @app = app
  end

  def call(env)
    ua = env["HTTP_USER_AGENT"] || ""
    bot = identify_bot(ua)

    if bot
      Thread.new do
        uri = URI("https://www.bluemonitor.org/api/v1/bot-visits")
        Net::HTTP.post(
          uri,
          {
            domain: "yourapp.com",
            visits: [{ bot_name: bot[:name], bot_category: bot[:category], path: env["PATH_INFO"], user_agent: ua }]
          }.to_json,
          "Authorization" => "Bearer #{ENV['BLUEMONITOR_API_KEY']}",
          "Content-Type" => "application/json"
        )
      rescue StandardError
        # ignore
      end
    end

    @app.call(env)
  end

  private

  def identify_bot(ua)
    BOT_PATTERNS.each do |pattern, name, category|
      return { name: name, category: category } if ua.match?(pattern)
    end
    nil
  end
end
```

Add to `config/application.rb`:

```ruby
config.middleware.use BotTrackingMiddleware
```

- Requires Pro plan + `BLUEMONITOR_API_KEY` env variable
- View results in the BlueMonitor dashboard under "Bot Tracking"
