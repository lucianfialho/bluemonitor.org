# BlueMonitor — Rails Setup Guide

Add uptime monitoring, heartbeat push, and a status badge to your Rails app.

Documentation: https://www.bluemonitor.org/docs/rails

## Important: Auto-detect the domain

Automatically detect the project's production domain from the codebase (check `.env`, `config/environments/production.rb` for `host`, or similar). Use the detected domain directly in the heartbeat URL — do NOT use placeholders like `yourapp.com`.

## 1. Health Endpoint (optional)

Add to `config/routes.rb`:

```ruby
get "/api/health", to: "health#show"
```

Create `app/controllers/health_controller.rb`:

```ruby
class HealthController < ApplicationController
  skip_before_action :authenticate_user!, raise: false

  def show
    render json: { status: "ok" }
  end
end
```

BlueMonitor pings this every 5 minutes. If it responds with 200 under 3s → operational. Over 3s → slow. Error/timeout → down.

## 2. Heartbeat Push (recommended)

Push detailed dependency health data to BlueMonitor using a recurring Sidekiq job.

```ruby
gem "sidekiq-cron"
```

**Requirements:**
- A BlueMonitor API key (create at https://www.bluemonitor.org/dashboard)
- The first heartbeat auto-registers the service and adds it to your watchlist

Create `app/jobs/heartbeat_job.rb`:

```ruby
class HeartbeatJob < ApplicationJob
  queue_as :default

  def perform
    checks = {}

    # Database check
    db_start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    begin
      ActiveRecord::Base.connection.execute("SELECT 1")
      checks[:database] = {
        status: "ok",
        latency: ((Process.clock_gettime(Process::CLOCK_MONOTONIC) - db_start) * 1000).round
      }
    rescue => e
      checks[:database] = {
        status: "error",
        latency: ((Process.clock_gettime(Process::CLOCK_MONOTONIC) - db_start) * 1000).round,
        message: e.message
      }
    end

    # Redis check
    redis_start = Process.clock_gettime(Process::CLOCK_MONOTONIC)
    begin
      Redis.current.ping
      checks[:redis] = {
        status: "ok",
        latency: ((Process.clock_gettime(Process::CLOCK_MONOTONIC) - redis_start) * 1000).round
      }
    rescue => e
      checks[:redis] = {
        status: "error",
        latency: ((Process.clock_gettime(Process::CLOCK_MONOTONIC) - redis_start) * 1000).round
      }
    end

    has_error = checks.values.any? { |c| c[:status] == "error" }

    uri = URI("https://www.bluemonitor.org/api/v1/heartbeat")
    Net::HTTP.post(
      uri,
      {
        domain: "yourapp.com",
        status: has_error ? "error" : "ok",
        timestamp: Time.now.utc.iso8601,
        checks: checks
      }.to_json,
      "Authorization" => "Bearer #{ENV['BLUEMONITOR_API_KEY']}",
      "Content-Type" => "application/json"
    )
  end
end
```

Add to `config/initializers/sidekiq_cron.rb`:

```ruby
Sidekiq::Cron::Job.create(
  name: "BlueMonitor heartbeat",
  cron: "*/5 * * * *",
  class: "HeartbeatJob"
)
```

Add to `.env`:

```
BLUEMONITOR_API_KEY=bm_your_api_key
```

## 3. Status Badge

Replace `your-domain-com` with your domain (dots become dashes). Place the badge in your footer for maximum visibility.

### ERB

```erb
<a href="https://www.bluemonitor.org/status/your-domain-com" target="_blank" rel="noopener">
  <img src="https://www.bluemonitor.org/api/badge/your-domain-com" alt="Status on BlueMonitor" height="36" />
</a>
```

### Markdown (README.md)

```markdown
[![Status](https://www.bluemonitor.org/api/badge/your-domain-com)](https://www.bluemonitor.org/status/your-domain-com)
```

## Heartbeat Request Schema

POST `https://www.bluemonitor.org/api/v1/heartbeat`

Headers: `Authorization: Bearer bm_...`, `Content-Type: application/json`

```json
{
  "domain": "yourapp.com",
  "status": "ok",
  "timestamp": "2026-02-12T12:00:00.000Z",
  "checks": {
    "database": { "status": "ok", "latency": 5 },
    "redis": { "status": "ok", "latency": 2 }
  }
}
```

- `domain`: your service's production domain (auto-detect from project config)
- `status`: "ok" or "error"
- `checks`: object with dependency names as keys, each with `status`, `latency` (ms), optional `message`
- If BlueMonitor stops receiving heartbeats for 10 minutes, the service is marked as down

## 4. Bot Tracking (Pro)

Track which bots crawl your Rails app. Requires a Pro plan and API key.

Create `app/middleware/bot_tracking_middleware.rb`:

```ruby
class BotTrackingMiddleware
  BOT_PATTERNS = [
    [/Googlebot/i, "googlebot", "search_engine"],
    [/bingbot/i, "bingbot", "search_engine"],
    [/GPTBot/i, "gptbot", "ai_crawler"],
    [/ChatGPT-User/i, "chatgpt-user", "ai_crawler"],
    [/ClaudeBot/i, "claudebot", "ai_crawler"],
    [/anthropic-ai/i, "anthropic-ai", "ai_crawler"],
    [/PerplexityBot/i, "perplexitybot", "ai_crawler"],
    [/Bytespider/i, "bytespider", "ai_crawler"],
    [/CCBot/i, "ccbot", "ai_crawler"],
    [/Meta-ExternalAgent/i, "meta-externalagent", "ai_crawler"],
    [/Google-Extended/i, "google-extended", "ai_crawler"],
    [/Twitterbot/i, "twitterbot", "social"],
    [/facebookexternalhit/i, "facebookbot", "social"],
    [/LinkedInBot/i, "linkedinbot", "social"],
    [/AhrefsBot/i, "ahrefsbot", "seo"],
    [/SemrushBot/i, "semrushbot", "seo"],
    [/UptimeRobot/i, "uptimerobot", "monitoring"],
  ].freeze

  def initialize(app)
    @app = app
  end

  def call(env)
    ua = env["HTTP_USER_AGENT"] || ""
    bot = identify_bot(ua)

    if bot
      Thread.new do
        uri = URI("https://www.bluemonitor.org/api/v1/bot-visits")
        Net::HTTP.post(
          uri,
          {
            domain: "yourapp.com",
            visits: [{ bot_name: bot[:name], bot_category: bot[:category], path: env["PATH_INFO"], user_agent: ua }]
          }.to_json,
          "Authorization" => "Bearer #{ENV['BLUEMONITOR_API_KEY']}",
          "Content-Type" => "application/json"
        )
      rescue StandardError
        # ignore
      end
    end

    @app.call(env)
  end

  private

  def identify_bot(ua)
    BOT_PATTERNS.each do |pattern, name, category|
      return { name: name, category: category } if ua.match?(pattern)
    end
    nil
  end
end
```

Add to `config/application.rb`:

```ruby
config.middleware.use BotTrackingMiddleware
```

- Requires Pro plan + `BLUEMONITOR_API_KEY` env variable
- View results in the BlueMonitor dashboard under "Bot Tracking"
